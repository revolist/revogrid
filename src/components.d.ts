/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AdditionalData, AfterEditEvent, AllDimensionType, ApplyFocusEvent, BeforeCellRenderEvent, BeforeEdit, BeforeRangeSaveDataDetails, BeforeRowRenderEvent, BeforeSaveDataDetails, Cell, CellTemplateProp, ChangedRange, ColumnDataSchemaModel, ColumnGrouping, ColumnProp, ColumnRegular, ColumnType, DataFormat, DataType, DimensionCols, DimensionRows, DimensionSettingsState, DimensionType, DimensionTypeCol, DragStartEvent, EditCell, EditorCtr, Editors, ElementScroll, ExtraNodeFuncConfig, FocusAfterRenderEvent, FocusRenderEvent, FocusTemplateFunc, InitialHeaderClick, MultiDimensionType, Nullable, PluginBaseComponent, PositionItem, ProvidersColumns, RangeArea, RangeClipboardCopyEventProps, RangeClipboardPasteEvent, RowDefinition, RowDragStartDetails, RowHeaders, SaveDataDetails, SelectionStoreState, TempRange, Theme, ViewportData, ViewPortResizeEvent, ViewPortScrollEvent, ViewportState, ViewSettingSizeProp } from "./types/index";
import { GridPlugin } from "./plugins/base.plugin";
import { AutoSizeColumnConfig } from "./plugins/column.auto-size.plugin";
import { ColumnFilterConfig, FilterCaptions, FilterCollectionItem, LogicFunction, MultiFilterItem, ShowData } from "./plugins/filter/filter.types";
import { SortingConfig, SortingOrder } from "./plugins";
import { GroupingOptions } from "./plugins/groupingRow/grouping.row.types";
import { VNode } from "@stencil/core";
import { FocusedData } from "./components/revoGrid/viewport.service";
import { ColumnCollection } from "./utils/column.utils";
import { DataInput } from "./plugins/export/types";
import { Observable } from "./utils";
import { DSourceState, Groups } from "./store/index";
import { ResizeProps } from "./components/header/resizable.directive";
import { HeaderRenderProps } from "./components/header/header-renderer";
import { HeaderGroupRendererProps } from "./components/header/header-group-renderer";
import { EventData } from "./components/overlay/selection.utils";
export { AdditionalData, AfterEditEvent, AllDimensionType, ApplyFocusEvent, BeforeCellRenderEvent, BeforeEdit, BeforeRangeSaveDataDetails, BeforeRowRenderEvent, BeforeSaveDataDetails, Cell, CellTemplateProp, ChangedRange, ColumnDataSchemaModel, ColumnGrouping, ColumnProp, ColumnRegular, ColumnType, DataFormat, DataType, DimensionCols, DimensionRows, DimensionSettingsState, DimensionType, DimensionTypeCol, DragStartEvent, EditCell, EditorCtr, Editors, ElementScroll, ExtraNodeFuncConfig, FocusAfterRenderEvent, FocusRenderEvent, FocusTemplateFunc, InitialHeaderClick, MultiDimensionType, Nullable, PluginBaseComponent, PositionItem, ProvidersColumns, RangeArea, RangeClipboardCopyEventProps, RangeClipboardPasteEvent, RowDefinition, RowDragStartDetails, RowHeaders, SaveDataDetails, SelectionStoreState, TempRange, Theme, ViewportData, ViewPortResizeEvent, ViewPortScrollEvent, ViewportState, ViewSettingSizeProp } from "./types/index";
export { GridPlugin } from "./plugins/base.plugin";
export { AutoSizeColumnConfig } from "./plugins/column.auto-size.plugin";
export { ColumnFilterConfig, FilterCaptions, FilterCollectionItem, LogicFunction, MultiFilterItem, ShowData } from "./plugins/filter/filter.types";
export { SortingConfig, SortingOrder } from "./plugins";
export { GroupingOptions } from "./plugins/groupingRow/grouping.row.types";
export { VNode } from "@stencil/core";
export { FocusedData } from "./components/revoGrid/viewport.service";
export { ColumnCollection } from "./utils/column.utils";
export { DataInput } from "./plugins/export/types";
export { Observable } from "./utils";
export { DSourceState, Groups } from "./store/index";
export { ResizeProps } from "./components/header/resizable.directive";
export { HeaderRenderProps } from "./components/header/header-renderer";
export { HeaderGroupRendererProps } from "./components/header/header-group-renderer";
export { EventData } from "./components/overlay/selection.utils";
export namespace Components {
    /**
     * Revogrid - High-performance, customizable grid library for managing large datasets.
     * ### Events guide
     * For a comprehensive events guide, check the [Events API Page](/guide/api/events).
     * All events propagate to the root level of the grid. [Dependency tree](#Dependencies).
     * ### Type definitions
     * Read [type definition file](https://github.com/revolist/revogrid/blob/master/src/interfaces.d.ts) for the full interface information.
     * All complex property types such as `ColumnRegular`, `ColumnProp`, `ColumnDataSchemaModel` can be found there.
     * ### HTMLRevoGridElement
     * @example data-rgCol-rgRow - main data slot. Applies extra elements in <revogr-data />.
     * @example focus-rgCol-rgRow - focus layer for main data. Applies extra elements in <revogr-focus />.
     */
    interface RevoGrid {
        /**
          * Enable accessibility. If disabled, the grid will not be accessible.
          * @default true
         */
        "accessible": boolean;
        /**
          * Add trimmed by type
         */
        "addTrimmed": (trimmed: Record<number, boolean>, trimmedType?: string, type?: DimensionRows) => Promise<CustomEvent<{ trimmed: Record<number, boolean>; trimmedType: string; type: string; }>>;
        /**
          * Additional data to be passed to plugins, renders or editors. For example if you need to pass Vue component instance.
         */
        "additionalData": AdditionalData;
        /**
          * Apply changes in editor when closed except 'Escape' cases. If custom editor in use method getValue required. Check interfaces.d.ts `EditorBase` for more info.
         */
        "applyOnClose": boolean;
        /**
          * Autosize config. Enables columns autoSize. For more details check `autoSizeColumn` plugin. By default disabled, hence operation is not performance efficient. `true` to enable with default params (double header separator click for autosize). Or define config. See `AutoSizeColumnConfig` for more details.
         */
        "autoSizeColumn": boolean | AutoSizeColumnConfig;
        /**
          * Disable native drag&drop plugin.
         */
        "canDrag": boolean;
        /**
          * When true cell focus appear.
         */
        "canFocus": boolean;
        /**
          * Enable column move plugin.
         */
        "canMoveColumns": boolean;
        /**
          * Clear current grid focus. Grid has no longer focus on it.
         */
        "clearFocus": () => Promise<void>;
        /**
          * Clears column sorting
         */
        "clearSorting": () => Promise<void>;
        /**
          * Indicates default column size.
         */
        "colSize": number;
        /**
          * Column Types Format. Every type represent multiple column properties. Types will be merged but can be replaced with column properties. Types were made as separate objects to be reusable per multiple columns.
         */
        "columnTypes": { [name: string]: ColumnType };
        /**
          * Columns - defines an array of grid columns. Can be column or grouped column.
         */
        "columns": (ColumnRegular | ColumnGrouping)[];
        /**
          * Disable lazy rendering mode for the `X axis`. Use when not many columns present and you don't need rerenader cells during scroll. Can be used for initial rendering performance improvement.
         */
        "disableVirtualX": boolean;
        /**
          * Disable lazy rendering mode for the `Y axis`. Use when not many rows present and you don't need rerenader cells during scroll. Can be used for initial rendering performance improvement.
         */
        "disableVirtualY": boolean;
        /**
          * Custom editors register.
         */
        "editors": Editors;
        /**
          * Enable export plugin.
         */
        "exporting": boolean;
        /**
          * Enables filter plugin. Can be boolean. Or can be filter collection See `FilterCollection` for more info.
         */
        "filter": boolean | ColumnFilterConfig;
        /**
          * Apply changes typed in editor on editor close except Escape cases. If custom editor in use method `getValue` required. Check `interfaces.d.ts` `EditorBase` for more info.
         */
        "focusTemplate": FocusTemplateFunc;
        /**
          * Defines how many rows/columns should be rendered outside visible area.
         */
        "frameSize": number;
        /**
          * Provides access to column internal store observer Can be used for plugin support
          * @param type - type of column
         */
        "getColumnStore": (type?: DimensionCols) => Promise<Observable<DSourceState<ColumnRegular, DimensionCols>>>;
        /**
          * Receive all columns in data source
         */
        "getColumns": () => Promise<ColumnRegular[]>;
        /**
          * Get size of content Including all pinned data
         */
        "getContentSize": () => Promise<Cell>;
        /**
          * Get the currently focused cell.
         */
        "getFocused": () => Promise<FocusedData | null>;
        /**
          * Get all active plugins instances
         */
        "getPlugins": () => Promise<PluginBaseComponent[]>;
        /**
          * Get the currently selected Range.
         */
        "getSelectedRange": () => Promise<(RangeArea & AllDimensionType) | null>;
        /**
          * Get data from source
         */
        "getSource": (type?: DimensionRows) => Promise<DataType[]>;
        /**
          * Provides access to rows internal store observer Can be used for plugin support
          * @param type - type of source
         */
        "getSourceStore": (type?: DimensionRows) => Promise<Observable<DSourceState<DataType, DimensionRows>>>;
        /**
          * Get data from visible part of source Trimmed/filtered rows will be excluded
          * @param type - type of source
         */
        "getVisibleSource": (type?: DimensionRows) => Promise<any[]>;
        /**
          * Group rows based on this property. Define properties to be groped by grouping plugin See `GroupingOptions`.
         */
        "grouping": GroupingOptions;
        /**
          * Please only hide the attribution if you are subscribed to Pro version
         */
        "hideAttribution": boolean;
        /**
          * Prevent rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender": Promise<any>[];
        /**
          * Pinned bottom Source: {[T in ColumnProp]: any} - defines pinned bottom rows data source.
         */
        "pinnedBottomSource": DataType[];
        /**
          * Pinned top Source: {[T in ColumnProp]: any} - defines pinned top rows data source.
         */
        "pinnedTopSource": DataType[];
        /**
          * Custom grid plugins. Can be added or removed at runtime. Every plugin should be inherited from BasePlugin class.  For more details check [Plugin guide](https://rv-grid.com/guide/plugin/)
         */
        "plugins": GridPlugin[];
        /**
          * When true, user can range selection.
         */
        "range": boolean;
        /**
          * When true, grid in read only mode.
         */
        "readonly": boolean;
        /**
          * Refreshes data viewport. Can be specific part as rgRow or pinned rgRow or 'all' by default.
         */
        "refresh": (type?: DimensionRows | "all") => Promise<void>;
        /**
          * Refresh extra elements. Triggers re-rendering of extra elements and functions. Part of extraElements and registerVNode methods. Useful for plugins.
         */
        "refreshExtraElements": () => Promise<void>;
        /**
          * Register new virtual node inside of grid. Used for additional items creation such as plugin elements. Should be set before grid render inside of plugins. Can return VNode result of h() function or a function that returns VNode. Function can be used for performance improvement and additional renders.
         */
        "registerVNode": (
    | VNode
    | ((c: ExtraNodeFuncConfig) => VNode)
  )[];
        /**
          * When true, columns are resizable.
         */
        "resize": boolean;
        /**
          * Row class property mapping. Map custom classes to rows from row object data. Define this property in rgRow object and this will be mapped as rgRow class.
         */
        "rowClass": string;
        /**
          * Custom row properies to be applied. See `RowDefinition` for more info.
         */
        "rowDefinitions": RowDefinition[];
        /**
          * Excel like functionality. Show row numbers. Also can be used for custom row header render if object provided.
         */
        "rowHeaders": RowHeaders | boolean;
        /**
          * Indicates default rgRow size. By default 0, means theme package size will be applied  Alternatively you can use `rowSize` to reset viewport
         */
        "rowSize": number;
        /**
          * Scrolls viewport to specified column by index.
         */
        "scrollToColumnIndex": (coordinate?: number) => Promise<void>;
        /**
          * Scrolls viewport to specified column by prop
         */
        "scrollToColumnProp": (prop: ColumnProp, dimension?: DimensionTypeCol) => Promise<void>;
        /**
          * Scrolls view port to coordinate
         */
        "scrollToCoordinate": (cell: Partial<Cell>) => Promise<void>;
        /**
          * Scrolls viewport to specified row by index.
         */
        "scrollToRow": (coordinate?: number) => Promise<void>;
        /**
          * Open editor for cell.
         */
        "setCellEdit": (rgRow: number, prop: ColumnProp, rowSource?: DimensionRows) => Promise<void>;
        /**
          * Set focus range.
         */
        "setCellsFocus": (cellStart?: Cell, cellEnd?: Cell, colType?: string, rowType?: string) => Promise<void>;
        /**
          * Refreshes data at specified cell. Useful for performance optimization. No viewport update will be triggered.
          * @example const grid = document.querySelector('revo-grid'); grid.setDataAt({ row: 0, col: 0, val: 'test' }); // refresh
         */
        "setDataAt": ({ row, col, colType, rowType, val, skipDataUpdate }: { row: number; col: number; val?: any; skipDataUpdate?: boolean; } & AllDimensionType) => Promise<void | undefined>;
        /**
          * Alternative way to set sorting. `{columns: [{prop: 'name', order: 'asc'}]}` Use SortingPlugin to get current sorting state
         */
        "sorting"?: SortingConfig;
        /**
          * Source - defines main data source. Can be an Object or 2 dimensional array([][]); Keys/indexes referenced from columns Prop.
         */
        "source": DataType[];
        /**
          * Stretch strategy for columns by `StretchColumn` plugin. For example if there are more space on the right last column size would be increased.
         */
        "stretch": boolean | string;
        /**
          * Theme name.
         */
        "theme": Theme;
        /**
          * Trimmed rows. Functionality which allows to hide rows from main data set. `trimmedRows` are physical `rgRow` indexes to hide.
         */
        "trimmedRows": Record<number, boolean>;
        /**
          * Update column sorting
          * @param column - column prop and cellCompare
          * @param order - order to apply
          * @param additive - if false will replace current order  later passed to SortingPlugin
         */
        "updateColumnSorting": (column: Pick<ColumnRegular, "prop" | "cellCompare">, order: "asc" | "desc" | undefined, additive: boolean) => Promise<void>;
        /**
          * Update columns
         */
        "updateColumns": (cols: ColumnRegular[]) => Promise<void>;
        /**
          * When true enable clipboard.
         */
        "useClipboard": boolean;
    }
    interface RevogrAttribution {
    }
    /**
     * This Clipboard provides functionality for handling clipboard events in a web application.
     */
    interface RevogrClipboard {
        "doCopy": (e: DataTransfer, data?: DataFormat[][]) => Promise<void>;
        /**
          * If readonly mode - disabled Paste event
         */
        "readonly": boolean;
    }
    /**
     * This component is responsible for rendering data
     * Rows, columns, groups and cells
     */
    interface RevogrData {
        /**
          * Additional data to pass to renderer Used in plugins such as vue or react to pass root app entity to cells
         */
        "additionalData": any;
        /**
          * Column source
         */
        "colData": Observable<DSourceState<ColumnRegular, DimensionCols>>;
        /**
          * Column data type
         */
        "colType": DimensionCols | 'rowHeaders';
        /**
          * Data rows source
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings Y
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Prevent rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender": (Promise<any> | (() => Promise<any>))[];
        /**
          * Range allowed
         */
        "range": boolean;
        /**
          * Readonly mode
         */
        "readonly": boolean;
        /**
          * Defines property from which to read row class
         */
        "rowClass": string;
        /**
          * Selection, range, focus for row selection
         */
        "rowSelectionStore": Observable<SelectionStoreState>;
        /**
          * Row data type
         */
        "type": DimensionRows;
        /**
          * Pointed cell update.
         */
        "updateCell": (e: { row: number; col: number; }) => Promise<void>;
        /**
          * Viewport X
         */
        "viewportCol": Observable<ViewportState>;
        /**
          * Viewport Y
         */
        "viewportRow": Observable<ViewportState>;
    }
    /**
     * Represents a cell editor in a grid.
     * It manages the editing of cells by handling events, saving data, rendering the editor UI,
     * and managing the lifecycle of the editor instance.
     */
    interface RevogrEdit {
        /**
          * Additional data to pass to renderer
         */
        "additionalData": any;
        /**
          * Before editor got disconnected. Can be triggered multiple times before actual disconnect.
         */
        "beforeDisconnect": () => Promise<void>;
        /**
          * Cancel pending changes flag. Editor will be closed without autosave.
         */
        "cancelChanges": () => Promise<void>;
        /**
          * Column data for editor.
         */
        "column": ColumnDataSchemaModel | null;
        /**
          * Cell to edit data.
         */
        "editCell": EditCell;
        /**
          * Custom editors register
         */
        "editor": EditorCtr | null;
        /**
          * Save on editor close. Defines if data should be saved on editor close.
         */
        "saveOnClose": boolean;
    }
    /**
     * Contains extra elements for stencil components.
     * Performs rendering and updates for external components.
     * @example In Plugins if you want to add extra elements to grid and use stenciljs vnodes reactivity:
     * function paginationPanel(this: PaginationPlugin, config: { refresh: () => void }) {
     *    // use `config.refresh()` for component to re-render
     *    return h('div')
     * }
     * revogrid.registerVNode = [
     *    ...existingNodes,
     *     paginationPanel.bind(this)
     * ];
     * /**
     */
    interface RevogrExtra {
        /**
          * Nodes to render
         */
        "nodes": (
    | VNode
    | ((c: ExtraNodeFuncConfig) => VNode)
  )[];
        /**
          * Refreshes the extra component. Useful if you want to manually force the component to re-render.
         */
        "refresh": () => Promise<void>;
    }
    interface RevogrFilterPanel {
        /**
          * If true, closes the filter panel when clicking outside
         */
        "closeOnOutsideClick": boolean;
        /**
          * Disables dynamic filtering. A way to apply filters on Save only
         */
        "disableDynamicFiltering": boolean;
        "filterCaptions": Partial<FilterCaptions> | undefined;
        "filterEntities": Record<string, LogicFunction>;
        "filterNames": Record<string, string>;
        "getChanges": () => Promise<ShowData | undefined>;
        "show": (newEntity?: ShowData) => Promise<void>;
    }
    /**
     * Focus component. Shows focus layer around the cell that is currently in focus.
     * @example focus-rgCol-rgRow
     */
    interface RevogrFocus {
        /**
          * Column source
         */
        "colData": Observable<DSourceState<ColumnRegular, DimensionCols>>;
        /**
          * Column type
         */
        "colType": DimensionCols;
        /**
          * Data rows source
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings X
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Dimension settings Y
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Focus template custom function. Can be used to render custom focus layer.
         */
        "focusTemplate": FocusTemplateFunc | null;
        /**
          * Row type
         */
        "rowType": DimensionRows;
        /**
          * Selection, range, focus for selection
         */
        "selectionStore": Observable<SelectionStoreState>;
    }
    interface RevogrHeader {
        /**
          * Extra properties to pass into header renderer, such as vue or react components to handle parent
         */
        "additionalData": any;
        /**
          * If columns can be resized
         */
        "canResize": boolean;
        /**
          * Columns - defines an array of grid columns.
         */
        "colData": ColumnRegular[];
        /**
          * Column filter
         */
        "columnFilter": boolean;
        /**
          * Dimension settings X
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Grouping depth, how many levels of grouping
         */
        "groupingDepth": number;
        /**
          * Column groups
         */
        "groups": Groups;
        /**
          * Readonly mode
         */
        "readonly": boolean;
        /**
          * Defines resize position
         */
        "resizeHandler": ResizeProps['active'];
        /**
          * Selection, range, focus
         */
        "selectionStore": Observable<SelectionStoreState>;
        /**
          * Column type
         */
        "type": DimensionCols | 'rowHeaders';
        /**
          * Viewport X
         */
        "viewportCol": Observable<ViewportState>;
    }
    /**
     * Component for handling row order editor.
     */
    interface RevogrOrderEditor {
        "clearOrder": () => Promise<void>;
        /**
          * Static stores, not expected to change during component lifetime
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings X
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Dimension settings Y
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        "dragStart": (e: DragStartEvent) => Promise<void>;
        "endOrder": (e: MouseEvent) => Promise<void>;
        /**
          * Parent element
         */
        "parent": HTMLElement;
        "rowType": DimensionRows;
    }
    /**
     * Component for overlaying the grid with the selection.
     */
    interface RevogrOverlaySelection {
        /**
          * Additional data to pass to renderer.
         */
        "additionalData": any;
        /**
          * If true applys changes when cell closes if not Escape.
         */
        "applyChangesOnClose": boolean;
        /**
          * Enable revogr-order-editor component (read more in revogr-order-editor component). Allows D&D.
         */
        "canDrag": boolean;
        /**
          * Column data store.
         */
        "colData": Observable<DSourceState<ColumnRegular, DimensionCols>>;
        /**
          * Row data store.
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings X.
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Dimension settings Y.
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Custom editors register.
         */
        "editors": Editors;
        /**
          * Is mobile view mode.
         */
        "isMobileDevice": boolean;
        /**
          * Last real coordinates positions + 1.
         */
        "lastCell": Cell;
        /**
          * Range selection allowed.
         */
        "range": boolean;
        /**
          * Readonly mode.
         */
        "readonly": boolean;
        /**
          * Selection, range, focus.
         */
        "selectionStore": Observable<SelectionStoreState>;
        /**
          * Enable revogr-clipboard component (read more in revogr-clipboard component). Allows copy/paste.
         */
        "useClipboard": boolean;
    }
    /**
     * Row headers component
     * Visible on the left side of the table
     */
    interface RevogrRowHeaders {
        /**
          * Additional data to pass to renderer
         */
        "additionalData": any;
        /**
          * Viewport data
         */
        "dataPorts": ViewportData[];
        /**
          * Header props
         */
        "headerProp": Record<string, any>;
        /**
          * Header height to setup row headers
         */
        "height": number;
        /**
          * Prevent rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender": Promise<any>[];
        /**
          * Enable resize
         */
        "resize": boolean;
        /**
          * Row class
         */
        "rowClass": string;
        /**
          * Row header column
         */
        "rowHeaderColumn": RowHeaders;
    }
    /**
     * Virtual scroll component
     */
    interface RevogrScrollVirtual {
        /**
          * Update if `delta` exists in case we don't know current position or if it's external change
         */
        "changeScroll": (e: ViewPortScrollEvent) => Promise<ViewPortScrollEvent>;
        /**
          * Client size
         */
        "clientSize": number;
        /**
          * Scroll dimension (`X` - `rgCol` or `Y` - `rgRow`)
         */
        "dimension": DimensionType;
        /**
          * Dimensions
         */
        "realSize": number;
        "setScroll": (e: ViewPortScrollEvent) => Promise<void>;
        /**
          * Virtual size
         */
        "virtualSize": number;
    }
    /**
     * Temporary range selection component. Shows temporary range selection.
     */
    interface RevogrTempRange {
        /**
          * Dimension column store
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Dimension row store
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Selection store, shows current selection and focus
         */
        "selectionStore": Observable<SelectionStoreState>;
    }
    /**
     * Viewport scroll component for RevoGrid
     */
    interface RevogrViewportScroll {
        /**
          * Extra layer for scroll event monitoring, where MouseWheel event is not passing We need to trigger scroll event in case there is no mousewheel event
         */
        "applyScroll": (type: DimensionType, e: UIEvent) => Promise<void>;
        /**
          * update on delta in case we don't know existing position or external change
          * @param e
         */
        "changeScroll": (e: ViewPortScrollEvent, silent?: boolean) => Promise<ViewPortScrollEvent | undefined>;
        "colType": DimensionCols | 'rowHeaders';
        /**
          * Height of inner content
         */
        "contentHeight": number;
        /**
          * Width of inner content
         */
        "contentWidth": number;
        /**
          * Enable row header
         */
        "rowHeader": boolean;
        "setScroll": (e: ViewPortScrollEvent) => Promise<void>;
    }
    interface VnodeHtml {
        "redraw": (() => VNode[]) | null | undefined;
    }
}
export interface RevoGridCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevoGridElement;
}
export interface RevogrClipboardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrClipboardElement;
}
export interface RevogrDataCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrDataElement;
}
export interface RevogrEditCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrEditElement;
}
export interface RevogrFilterPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrFilterPanelElement;
}
export interface RevogrFocusCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrFocusElement;
}
export interface RevogrHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrHeaderElement;
}
export interface RevogrOrderEditorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrOrderEditorElement;
}
export interface RevogrOverlaySelectionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrOverlaySelectionElement;
}
export interface RevogrRowHeadersCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrRowHeadersElement;
}
export interface RevogrScrollVirtualCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrScrollVirtualElement;
}
export interface RevogrViewportScrollCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRevogrViewportScrollElement;
}
export interface VnodeHtmlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLVnodeHtmlElement;
}
declare global {
    interface HTMLRevoGridElementEventMap {
        "contentsizechanged": MultiDimensionType;
        "beforeedit": BeforeSaveDataDetails;
        "beforerangeedit": BeforeRangeSaveDataDetails;
        "afteredit": AfterEditEvent;
        "beforeautofill": ChangedRange;
        "beforerange": ChangedRange;
        "afterfocus": FocusAfterRenderEvent;
        "roworderchanged": { from: number; to: number };
        "beforesorting": {
    column: ColumnRegular;
    order: 'desc' | 'asc';
    additive: boolean;
  };
        "beforesourcesortingapply": {
    type: DimensionRows;
    sorting?: SortingOrder;
  };
        "beforesortingapply": {
    column: ColumnRegular;
    order: 'desc' | 'asc';
    additive: boolean;
  };
        "rowdragstart": RowDragStartDetails;
        "headerclick": ColumnRegular;
        "beforecellfocus": BeforeSaveDataDetails;
        "beforefocuslost": FocusedData | null;
        "beforesourceset": {
    type: DimensionRows;
    source: DataType[];
  };
        "beforeanysource": {
    type: DimensionRows;
    source: DataType[];
  };
        "aftersourceset": {
    type: DimensionRows;
    source: DataType[];
  };
        "afteranysource": {
    type: DimensionRows;
    source: DataType[];
  };
        "beforecolumnsset": ColumnCollection;
        "beforecolumnapplied": ColumnCollection;
        "aftercolumnsset": {
    columns: ColumnCollection;
    order: SortingOrder;
  };
        "beforefilterapply": { collection: Record<ColumnProp, FilterCollectionItem> };
        "beforefiltertrimmed": {
    collection: Record<ColumnProp, FilterCollectionItem>;
    itemsToFilter: Record<number, boolean>;
  };
        "beforetrimmed": {
    trimmed: Record<number, boolean>;
    trimmedType: string;
    type: string;
  };
        "aftertrimmed": any;
        "viewportscroll": ViewPortScrollEvent;
        "beforeexport": DataInput;
        "beforeeditstart": BeforeSaveDataDetails;
        "aftercolumnresize": {
    [index: number]: ColumnRegular;
  };
        "beforerowdefinition": { vals: any; oldVals: any };
        "filterconfigchanged": any;
        "sortingconfigchanged": SortingConfig;
        "rowheaderschanged": any;
        "beforegridrender": any;
        "aftergridrender": any;
        "aftergridinit": any;
        "additionaldatachanged": any;
        "afterthemechanged": Theme;
        "created": any;
    }
    /**
     * Revogrid - High-performance, customizable grid library for managing large datasets.
     * ### Events guide
     * For a comprehensive events guide, check the [Events API Page](/guide/api/events).
     * All events propagate to the root level of the grid. [Dependency tree](#Dependencies).
     * ### Type definitions
     * Read [type definition file](https://github.com/revolist/revogrid/blob/master/src/interfaces.d.ts) for the full interface information.
     * All complex property types such as `ColumnRegular`, `ColumnProp`, `ColumnDataSchemaModel` can be found there.
     * ### HTMLRevoGridElement
     * @example data-rgCol-rgRow - main data slot. Applies extra elements in <revogr-data />.
     * @example focus-rgCol-rgRow - focus layer for main data. Applies extra elements in <revogr-focus />.
     */
    interface HTMLRevoGridElement extends Components.RevoGrid, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevoGridElementEventMap>(type: K, listener: (this: HTMLRevoGridElement, ev: RevoGridCustomEvent<HTMLRevoGridElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevoGridElementEventMap>(type: K, listener: (this: HTMLRevoGridElement, ev: RevoGridCustomEvent<HTMLRevoGridElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevoGridElement: {
        prototype: HTMLRevoGridElement;
        new (): HTMLRevoGridElement;
    };
    interface HTMLRevogrAttributionElement extends Components.RevogrAttribution, HTMLStencilElement {
    }
    var HTMLRevogrAttributionElement: {
        prototype: HTMLRevogrAttributionElement;
        new (): HTMLRevogrAttributionElement;
    };
    interface HTMLRevogrClipboardElementEventMap {
        "beforepaste": {
    raw: string;
    isHTML: boolean;
    event: ClipboardEvent;
    dataText: string;
  };
        "beforepasteapply": {
    raw: string;
    parsed: string[][];
    event: ClipboardEvent;
  };
        "pasteregion": string[][];
        "afterpasteapply": {
    raw: string;
    parsed: string[][];
    event: ClipboardEvent;
  };
        "beforecut": {
    event: ClipboardEvent;
  };
        "clearregion": DataTransfer;
        "beforecopy": {
    event: ClipboardEvent;
  };
        "beforecopyapply": {
    event: DataTransfer;
    data?: string[][];
  };
        "copyregion": DataTransfer;
    }
    /**
     * This Clipboard provides functionality for handling clipboard events in a web application.
     */
    interface HTMLRevogrClipboardElement extends Components.RevogrClipboard, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrClipboardElementEventMap>(type: K, listener: (this: HTMLRevogrClipboardElement, ev: RevogrClipboardCustomEvent<HTMLRevogrClipboardElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrClipboardElementEventMap>(type: K, listener: (this: HTMLRevogrClipboardElement, ev: RevogrClipboardCustomEvent<HTMLRevogrClipboardElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrClipboardElement: {
        prototype: HTMLRevogrClipboardElement;
        new (): HTMLRevogrClipboardElement;
    };
    interface HTMLRevogrDataElementEventMap {
        "beforerowrender": BeforeRowRenderEvent;
        "afterrender": { type: DimensionRows };
        "beforecellrender": BeforeCellRenderEvent<CellTemplateProp>;
        "beforedatarender": AllDimensionType;
        "dragstartcell": DragStartEvent;
    }
    /**
     * This component is responsible for rendering data
     * Rows, columns, groups and cells
     */
    interface HTMLRevogrDataElement extends Components.RevogrData, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrDataElementEventMap>(type: K, listener: (this: HTMLRevogrDataElement, ev: RevogrDataCustomEvent<HTMLRevogrDataElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrDataElementEventMap>(type: K, listener: (this: HTMLRevogrDataElement, ev: RevogrDataCustomEvent<HTMLRevogrDataElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrDataElement: {
        prototype: HTMLRevogrDataElement;
        new (): HTMLRevogrDataElement;
    };
    interface HTMLRevogrEditElementEventMap {
        "celleditinit": SaveDataDetails;
        "closeedit": boolean | undefined;
    }
    /**
     * Represents a cell editor in a grid.
     * It manages the editing of cells by handling events, saving data, rendering the editor UI,
     * and managing the lifecycle of the editor instance.
     */
    interface HTMLRevogrEditElement extends Components.RevogrEdit, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrEditElementEventMap>(type: K, listener: (this: HTMLRevogrEditElement, ev: RevogrEditCustomEvent<HTMLRevogrEditElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrEditElementEventMap>(type: K, listener: (this: HTMLRevogrEditElement, ev: RevogrEditCustomEvent<HTMLRevogrEditElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrEditElement: {
        prototype: HTMLRevogrEditElement;
        new (): HTMLRevogrEditElement;
    };
    /**
     * Contains extra elements for stencil components.
     * Performs rendering and updates for external components.
     * @example In Plugins if you want to add extra elements to grid and use stenciljs vnodes reactivity:
     * function paginationPanel(this: PaginationPlugin, config: { refresh: () => void }) {
     *    // use `config.refresh()` for component to re-render
     *    return h('div')
     * }
     * revogrid.registerVNode = [
     *    ...existingNodes,
     *     paginationPanel.bind(this)
     * ];
     * /**
     */
    interface HTMLRevogrExtraElement extends Components.RevogrExtra, HTMLStencilElement {
    }
    var HTMLRevogrExtraElement: {
        prototype: HTMLRevogrExtraElement;
        new (): HTMLRevogrExtraElement;
    };
    interface HTMLRevogrFilterPanelElementEventMap {
        "filterChange": MultiFilterItem;
        "resetChange": ColumnProp;
    }
    interface HTMLRevogrFilterPanelElement extends Components.RevogrFilterPanel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrFilterPanelElementEventMap>(type: K, listener: (this: HTMLRevogrFilterPanelElement, ev: RevogrFilterPanelCustomEvent<HTMLRevogrFilterPanelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrFilterPanelElementEventMap>(type: K, listener: (this: HTMLRevogrFilterPanelElement, ev: RevogrFilterPanelCustomEvent<HTMLRevogrFilterPanelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrFilterPanelElement: {
        prototype: HTMLRevogrFilterPanelElement;
        new (): HTMLRevogrFilterPanelElement;
    };
    interface HTMLRevogrFocusElementEventMap {
        "beforefocusrender": FocusRenderEvent;
        "beforescrollintoview": { el: HTMLElement };
        "afterfocus": FocusAfterRenderEvent;
    }
    /**
     * Focus component. Shows focus layer around the cell that is currently in focus.
     * @example focus-rgCol-rgRow
     */
    interface HTMLRevogrFocusElement extends Components.RevogrFocus, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrFocusElementEventMap>(type: K, listener: (this: HTMLRevogrFocusElement, ev: RevogrFocusCustomEvent<HTMLRevogrFocusElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrFocusElementEventMap>(type: K, listener: (this: HTMLRevogrFocusElement, ev: RevogrFocusCustomEvent<HTMLRevogrFocusElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrFocusElement: {
        prototype: HTMLRevogrFocusElement;
        new (): HTMLRevogrFocusElement;
    };
    interface HTMLRevogrHeaderElementEventMap {
        "beforeheaderclick": InitialHeaderClick;
        "headerresize": ViewSettingSizeProp;
        "beforeheaderresize": ColumnRegular[];
        "headerdblclick": InitialHeaderClick;
        "beforeheaderrender": HeaderRenderProps;
        "beforegroupheaderrender": HeaderGroupRendererProps;
        "afterheaderrender": ProvidersColumns;
    }
    interface HTMLRevogrHeaderElement extends Components.RevogrHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrHeaderElementEventMap>(type: K, listener: (this: HTMLRevogrHeaderElement, ev: RevogrHeaderCustomEvent<HTMLRevogrHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrHeaderElementEventMap>(type: K, listener: (this: HTMLRevogrHeaderElement, ev: RevogrHeaderCustomEvent<HTMLRevogrHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrHeaderElement: {
        prototype: HTMLRevogrHeaderElement;
        new (): HTMLRevogrHeaderElement;
    };
    interface HTMLRevogrOrderEditorElementEventMap {
        "rowdragstartinit": RowDragStartDetails;
        "rowdragendinit": { rowType: DimensionRows };
        "rowdragmoveinit": PositionItem & { rowType: DimensionRows };
        "rowdragmousemove": Cell & { rowType: DimensionRows };
        "rowdropinit": {
    from: number;
    to: number;
    rowType: DimensionRows;
  };
        "roworderchange": {
    from: number;
    to: number;
    rowType: DimensionRows;
  };
    }
    /**
     * Component for handling row order editor.
     */
    interface HTMLRevogrOrderEditorElement extends Components.RevogrOrderEditor, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrOrderEditorElementEventMap>(type: K, listener: (this: HTMLRevogrOrderEditorElement, ev: RevogrOrderEditorCustomEvent<HTMLRevogrOrderEditorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrOrderEditorElementEventMap>(type: K, listener: (this: HTMLRevogrOrderEditorElement, ev: RevogrOrderEditorCustomEvent<HTMLRevogrOrderEditorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrOrderEditorElement: {
        prototype: HTMLRevogrOrderEditorElement;
        new (): HTMLRevogrOrderEditorElement;
    };
    interface HTMLRevogrOverlaySelectionElementEventMap {
        "beforecopyregion": any;
        "beforepasteregion": any;
        "celleditapply": BeforeSaveDataDetails;
        "beforecellfocusinit": BeforeSaveDataDetails;
        "beforenextvpfocus": Cell;
        "setedit": BeforeEdit;
        "beforeapplyrange": FocusRenderEvent;
        "beforesetrange": any;
        "setrange": RangeArea & { type: MultiDimensionType };
        "beforeeditrender": FocusRenderEvent;
        "selectall": any;
        "canceledit": any;
        "settemprange": Nullable<TempRange> | null;
        "beforesettemprange": { tempRange: Nullable<TempRange> | null } & EventData & AllDimensionType;
        "applyfocus": FocusRenderEvent;
        "focuscell": ApplyFocusEvent & FocusRenderEvent;
        "beforerangedataapply": FocusRenderEvent;
        "selectionchangeinit": ChangedRange;
        "beforerangecopyapply": ChangedRange;
        "rangeeditapply": BeforeRangeSaveDataDetails;
        "clipboardrangecopy": RangeClipboardCopyEventProps;
        "clipboardrangepaste": RangeClipboardPasteEvent;
        "beforekeydown": { original: KeyboardEvent } & EventData;
        "beforekeyup": { original: KeyboardEvent } & EventData;
        "beforecellsave": any;
        "celledit": SaveDataDetails;
    }
    /**
     * Component for overlaying the grid with the selection.
     */
    interface HTMLRevogrOverlaySelectionElement extends Components.RevogrOverlaySelection, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrOverlaySelectionElementEventMap>(type: K, listener: (this: HTMLRevogrOverlaySelectionElement, ev: RevogrOverlaySelectionCustomEvent<HTMLRevogrOverlaySelectionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrOverlaySelectionElementEventMap>(type: K, listener: (this: HTMLRevogrOverlaySelectionElement, ev: RevogrOverlaySelectionCustomEvent<HTMLRevogrOverlaySelectionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrOverlaySelectionElement: {
        prototype: HTMLRevogrOverlaySelectionElement;
        new (): HTMLRevogrOverlaySelectionElement;
    };
    interface HTMLRevogrRowHeadersElementEventMap {
        "scrollview": ViewPortScrollEvent;
        "ref": ElementScroll;
    }
    /**
     * Row headers component
     * Visible on the left side of the table
     */
    interface HTMLRevogrRowHeadersElement extends Components.RevogrRowHeaders, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrRowHeadersElementEventMap>(type: K, listener: (this: HTMLRevogrRowHeadersElement, ev: RevogrRowHeadersCustomEvent<HTMLRevogrRowHeadersElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrRowHeadersElementEventMap>(type: K, listener: (this: HTMLRevogrRowHeadersElement, ev: RevogrRowHeadersCustomEvent<HTMLRevogrRowHeadersElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrRowHeadersElement: {
        prototype: HTMLRevogrRowHeadersElement;
        new (): HTMLRevogrRowHeadersElement;
    };
    interface HTMLRevogrScrollVirtualElementEventMap {
        "scrollvirtual": ViewPortScrollEvent;
    }
    /**
     * Virtual scroll component
     */
    interface HTMLRevogrScrollVirtualElement extends Components.RevogrScrollVirtual, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrScrollVirtualElementEventMap>(type: K, listener: (this: HTMLRevogrScrollVirtualElement, ev: RevogrScrollVirtualCustomEvent<HTMLRevogrScrollVirtualElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrScrollVirtualElementEventMap>(type: K, listener: (this: HTMLRevogrScrollVirtualElement, ev: RevogrScrollVirtualCustomEvent<HTMLRevogrScrollVirtualElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrScrollVirtualElement: {
        prototype: HTMLRevogrScrollVirtualElement;
        new (): HTMLRevogrScrollVirtualElement;
    };
    /**
     * Temporary range selection component. Shows temporary range selection.
     */
    interface HTMLRevogrTempRangeElement extends Components.RevogrTempRange, HTMLStencilElement {
    }
    var HTMLRevogrTempRangeElement: {
        prototype: HTMLRevogrTempRangeElement;
        new (): HTMLRevogrTempRangeElement;
    };
    interface HTMLRevogrViewportScrollElementEventMap {
        "scrollviewport": ViewPortScrollEvent;
        "resizeviewport": ViewPortResizeEvent;
        "scrollchange": {
    type: DimensionType;
    hasScroll: boolean;
  };
        "scrollviewportsilent": ViewPortScrollEvent;
    }
    /**
     * Viewport scroll component for RevoGrid
     */
    interface HTMLRevogrViewportScrollElement extends Components.RevogrViewportScroll, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRevogrViewportScrollElementEventMap>(type: K, listener: (this: HTMLRevogrViewportScrollElement, ev: RevogrViewportScrollCustomEvent<HTMLRevogrViewportScrollElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRevogrViewportScrollElementEventMap>(type: K, listener: (this: HTMLRevogrViewportScrollElement, ev: RevogrViewportScrollCustomEvent<HTMLRevogrViewportScrollElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRevogrViewportScrollElement: {
        prototype: HTMLRevogrViewportScrollElement;
        new (): HTMLRevogrViewportScrollElement;
    };
    interface HTMLVnodeHtmlElementEventMap {
        "html": { html: string; vnodes: (VNode[]) | null };
    }
    interface HTMLVnodeHtmlElement extends Components.VnodeHtml, HTMLStencilElement {
        addEventListener<K extends keyof HTMLVnodeHtmlElementEventMap>(type: K, listener: (this: HTMLVnodeHtmlElement, ev: VnodeHtmlCustomEvent<HTMLVnodeHtmlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLVnodeHtmlElementEventMap>(type: K, listener: (this: HTMLVnodeHtmlElement, ev: VnodeHtmlCustomEvent<HTMLVnodeHtmlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLVnodeHtmlElement: {
        prototype: HTMLVnodeHtmlElement;
        new (): HTMLVnodeHtmlElement;
    };
    interface HTMLElementTagNameMap {
        "revo-grid": HTMLRevoGridElement;
        "revogr-attribution": HTMLRevogrAttributionElement;
        "revogr-clipboard": HTMLRevogrClipboardElement;
        "revogr-data": HTMLRevogrDataElement;
        "revogr-edit": HTMLRevogrEditElement;
        "revogr-extra": HTMLRevogrExtraElement;
        "revogr-filter-panel": HTMLRevogrFilterPanelElement;
        "revogr-focus": HTMLRevogrFocusElement;
        "revogr-header": HTMLRevogrHeaderElement;
        "revogr-order-editor": HTMLRevogrOrderEditorElement;
        "revogr-overlay-selection": HTMLRevogrOverlaySelectionElement;
        "revogr-row-headers": HTMLRevogrRowHeadersElement;
        "revogr-scroll-virtual": HTMLRevogrScrollVirtualElement;
        "revogr-temp-range": HTMLRevogrTempRangeElement;
        "revogr-viewport-scroll": HTMLRevogrViewportScrollElement;
        "vnode-html": HTMLVnodeHtmlElement;
    }
}
declare namespace LocalJSX {
    /**
     * Revogrid - High-performance, customizable grid library for managing large datasets.
     * ### Events guide
     * For a comprehensive events guide, check the [Events API Page](/guide/api/events).
     * All events propagate to the root level of the grid. [Dependency tree](#Dependencies).
     * ### Type definitions
     * Read [type definition file](https://github.com/revolist/revogrid/blob/master/src/interfaces.d.ts) for the full interface information.
     * All complex property types such as `ColumnRegular`, `ColumnProp`, `ColumnDataSchemaModel` can be found there.
     * ### HTMLRevoGridElement
     * @example data-rgCol-rgRow - main data slot. Applies extra elements in <revogr-data />.
     * @example focus-rgCol-rgRow - focus layer for main data. Applies extra elements in <revogr-focus />.
     */
    interface RevoGrid {
        /**
          * Enable accessibility. If disabled, the grid will not be accessible.
          * @default true
         */
        "accessible"?: boolean;
        /**
          * Additional data to be passed to plugins, renders or editors. For example if you need to pass Vue component instance.
         */
        "additionalData"?: AdditionalData;
        /**
          * Apply changes in editor when closed except 'Escape' cases. If custom editor in use method getValue required. Check interfaces.d.ts `EditorBase` for more info.
         */
        "applyOnClose"?: boolean;
        /**
          * Autosize config. Enables columns autoSize. For more details check `autoSizeColumn` plugin. By default disabled, hence operation is not performance efficient. `true` to enable with default params (double header separator click for autosize). Or define config. See `AutoSizeColumnConfig` for more details.
         */
        "autoSizeColumn"?: boolean | AutoSizeColumnConfig;
        /**
          * Disable native drag&drop plugin.
         */
        "canDrag"?: boolean;
        /**
          * When true cell focus appear.
         */
        "canFocus"?: boolean;
        /**
          * Enable column move plugin.
         */
        "canMoveColumns"?: boolean;
        /**
          * Indicates default column size.
         */
        "colSize"?: number;
        /**
          * Column Types Format. Every type represent multiple column properties. Types will be merged but can be replaced with column properties. Types were made as separate objects to be reusable per multiple columns.
         */
        "columnTypes"?: { [name: string]: ColumnType };
        /**
          * Columns - defines an array of grid columns. Can be column or grouped column.
         */
        "columns"?: (ColumnRegular | ColumnGrouping)[];
        /**
          * Disable lazy rendering mode for the `X axis`. Use when not many columns present and you don't need rerenader cells during scroll. Can be used for initial rendering performance improvement.
         */
        "disableVirtualX"?: boolean;
        /**
          * Disable lazy rendering mode for the `Y axis`. Use when not many rows present and you don't need rerenader cells during scroll. Can be used for initial rendering performance improvement.
         */
        "disableVirtualY"?: boolean;
        /**
          * Custom editors register.
         */
        "editors"?: Editors;
        /**
          * Enable export plugin.
         */
        "exporting"?: boolean;
        /**
          * Enables filter plugin. Can be boolean. Or can be filter collection See `FilterCollection` for more info.
         */
        "filter"?: boolean | ColumnFilterConfig;
        /**
          * Apply changes typed in editor on editor close except Escape cases. If custom editor in use method `getValue` required. Check `interfaces.d.ts` `EditorBase` for more info.
         */
        "focusTemplate"?: FocusTemplateFunc;
        /**
          * Defines how many rows/columns should be rendered outside visible area.
         */
        "frameSize"?: number;
        /**
          * Group rows based on this property. Define properties to be groped by grouping plugin See `GroupingOptions`.
         */
        "grouping"?: GroupingOptions;
        /**
          * Please only hide the attribution if you are subscribed to Pro version
         */
        "hideAttribution"?: boolean;
        /**
          * Prevent rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender"?: Promise<any>[];
        /**
          * Emmited after the additional data is changed
         */
        "onAdditionaldatachanged"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Emitted after each source update, whether from the pinned or main viewport. Useful for tracking all changes originating from sources in both the pinned and main viewports.
         */
        "onAfteranysource"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * Emitted after column resizing. Useful for retrieving the resized columns.
         */
        "onAftercolumnresize"?: (event: RevoGridCustomEvent<{
    [index: number]: ColumnRegular;
  }>) => void;
        /**
          * Column updated
         */
        "onAftercolumnsset"?: (event: RevoGridCustomEvent<{
    columns: ColumnCollection;
    order: SortingOrder;
  }>) => void;
        /**
          * After data applied or range changed.
         */
        "onAfteredit"?: (event: RevoGridCustomEvent<AfterEditEvent>) => void;
        /**
          * After focus render finished. Can be used to access a focus element through `event.target`. This is just a duplicate of `afterfocus` from `revogr-focus.tsx`.
         */
        "onAfterfocus"?: (event: RevoGridCustomEvent<FocusAfterRenderEvent>) => void;
        /**
          * Emmited after the grid is initialized. Connected to the DOM.
         */
        "onAftergridinit"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Emmited after the grid is rendered.
         */
        "onAftergridrender"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * After main source/rows updated
         */
        "onAftersourceset"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * Emmited after the theme is changed
         */
        "onAfterthemechanged"?: (event: RevoGridCustomEvent<Theme>) => void;
        /**
          * Emitted after trimmed values have been applied. Useful for notifying when trimming of values has taken place.
         */
        "onAftertrimmed"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Before data apply on any source type. Can be source from pinned and main viewport. You can override data source here
         */
        "onBeforeanysource"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * Before autofill is applied. To prevent the default behavior of applying the edit data, you can call `e.preventDefault()`.
         */
        "onBeforeautofill"?: (event: RevoGridCustomEvent<ChangedRange>) => void;
        /**
          * Before the cell focus is changed. To prevent the default behavior of changing the cell focus, you can call `e.preventDefault()`.
         */
        "onBeforecellfocus"?: (event: RevoGridCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Emitted before a column update is applied, after the column set is gathered and the viewport is updated. Useful for performing actions or modifications before the final application of the column update.
         */
        "onBeforecolumnapplied"?: (event: RevoGridCustomEvent<ColumnCollection>) => void;
        /**
          * Emitted before a column update is applied. Listeners can use this event to perform any necessary actions or modifications before the column update is finalized.
         */
        "onBeforecolumnsset"?: (event: RevoGridCustomEvent<ColumnCollection>) => void;
        /**
          * Before the data is edited. To prevent the default behavior of editing data and use your own implementation, call `e.preventDefault()`. To override the edit result with your own value, set the `e.val` property to your desired value.
         */
        "onBeforeedit"?: (event: RevoGridCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Emitted before editing starts. Use e.preventDefault() to prevent the default edit behavior.
         */
        "onBeforeeditstart"?: (event: RevoGridCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Before export Use e.preventDefault() to prevent export Replace data in Event in case you want to modify it in export
         */
        "onBeforeexport"?: (event: RevoGridCustomEvent<DataInput>) => void;
        /**
          * Emitted before applying a filter to the data source. Use e.preventDefault() to prevent cell focus change. Modify if you need to change filters.
         */
        "onBeforefilterapply"?: (event: RevoGridCustomEvent<{ collection: Record<ColumnProp, FilterCollectionItem> }>) => void;
        /**
          * Emitted before applying a filter to the data source. Use e.preventDefault() to prevent the default behavior of trimming values and applying the filter. Modify the `collection` property if you want to change the filters. Modify the `itemsToFilter` property if you want to filter the indexes for trimming.
         */
        "onBeforefiltertrimmed"?: (event: RevoGridCustomEvent<{
    collection: Record<ColumnProp, FilterCollectionItem>;
    itemsToFilter: Record<number, boolean>;
  }>) => void;
        /**
          * Before the grid focus is lost. To prevent the default behavior of changing the cell focus, you can call `e.preventDefault()`.
         */
        "onBeforefocuslost"?: (event: RevoGridCustomEvent<FocusedData | null>) => void;
        /**
          * Emmited before the grid is rendered.
         */
        "onBeforegridrender"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Before autofill is applied. Runs before beforeautofill event. Use e.preventDefault() to prevent range.
         */
        "onBeforerange"?: (event: RevoGridCustomEvent<ChangedRange>) => void;
        /**
          * Before applying range data, specifically when a range selection occurs. To customize the data and prevent the default edit data from being set, you can call `e.preventDefault()`.
         */
        "onBeforerangeedit"?: (event: RevoGridCustomEvent<BeforeRangeSaveDataDetails>) => void;
        /**
          * Emitted before the row definition is applied. Useful for modifying or preventing the default row definition behavior.
         */
        "onBeforerowdefinition"?: (event: RevoGridCustomEvent<{ vals: any; oldVals: any }>) => void;
        /**
          * By `SortingPlugin` <br>Triggered immediately after header click. <br>First in sorting event sequence. Ff this event stops no other event called. <br>Use `e.preventDefault()` to prevent sorting.
         */
        "onBeforesorting"?: (event: RevoGridCustomEvent<{
    column: ColumnRegular;
    order: 'desc' | 'asc';
    additive: boolean;
  }>) => void;
        /**
          * By `SortingPlugin` <br> After `beforesorting` <br>Triggered after column data updated with new sorting order. <br>Use `e.preventDefault()` to prevent sorting data change.
         */
        "onBeforesortingapply"?: (event: RevoGridCustomEvent<{
    column: ColumnRegular;
    order: 'desc' | 'asc';
    additive: boolean;
  }>) => void;
        /**
          * Before main source/rows data apply. You can override data source here
         */
        "onBeforesourceset"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    source: DataType[];
  }>) => void;
        /**
          * By `SortingPlugin` <br>Same as `beforesorting` but triggered after `beforeanysource` (when source is changed). <br>Use `e.preventDefault()` to prevent sorting data change.
         */
        "onBeforesourcesortingapply"?: (event: RevoGridCustomEvent<{
    type: DimensionRows;
    sorting?: SortingOrder;
  }>) => void;
        /**
          * Emitted before trimming values. Use e.preventDefault() to prevent the default behavior of trimming values. Modify the `trimmed` property if you want to filter the indexes for trimming.
         */
        "onBeforetrimmed"?: (event: RevoGridCustomEvent<{
    trimmed: Record<number, boolean>;
    trimmedType: string;
    type: string;
  }>) => void;
        /**
          * New content size has been applied. The size excludes the header. Currently, the event responsible for applying the new content size does not provide the actual size. To retrieve the actual content size, you can utilize the `getContentSize` function after the event has been triggered.
         */
        "onContentsizechanged"?: (event: RevoGridCustomEvent<MultiDimensionType>) => void;
        /**
          * Emmited after grid created
         */
        "onCreated"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Emitted when the filter configuration is changed
         */
        "onFilterconfigchanged"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * On header click.
         */
        "onHeaderclick"?: (event: RevoGridCustomEvent<ColumnRegular>) => void;
        /**
          * This event is triggered when the row order change is started. To prevent the default behavior of changing the row order, you can call `e.preventDefault()`. To change the item name at the start of the row order change, you can set `e.text` to the desired new name.
         */
        "onRowdragstart"?: (event: RevoGridCustomEvent<RowDragStartDetails>) => void;
        /**
          * Emmited when the row headers are changed.
         */
        "onRowheaderschanged"?: (event: RevoGridCustomEvent<any>) => void;
        /**
          * Before the order of `rgRow` is applied. To prevent the default behavior of changing the order of `rgRow`, you can call `e.preventDefault()`.
         */
        "onRoworderchanged"?: (event: RevoGridCustomEvent<{ from: number; to: number }>) => void;
        /**
          * Emitted when the sorting configuration is changed SortingPlugin subsribed to this event
         */
        "onSortingconfigchanged"?: (event: RevoGridCustomEvent<SortingConfig>) => void;
        /**
          * Emitted when the viewport is scrolled. Useful for tracking viewport scrolling events.
         */
        "onViewportscroll"?: (event: RevoGridCustomEvent<ViewPortScrollEvent>) => void;
        /**
          * Pinned bottom Source: {[T in ColumnProp]: any} - defines pinned bottom rows data source.
         */
        "pinnedBottomSource"?: DataType[];
        /**
          * Pinned top Source: {[T in ColumnProp]: any} - defines pinned top rows data source.
         */
        "pinnedTopSource"?: DataType[];
        /**
          * Custom grid plugins. Can be added or removed at runtime. Every plugin should be inherited from BasePlugin class.  For more details check [Plugin guide](https://rv-grid.com/guide/plugin/)
         */
        "plugins"?: GridPlugin[];
        /**
          * When true, user can range selection.
         */
        "range"?: boolean;
        /**
          * When true, grid in read only mode.
         */
        "readonly"?: boolean;
        /**
          * Register new virtual node inside of grid. Used for additional items creation such as plugin elements. Should be set before grid render inside of plugins. Can return VNode result of h() function or a function that returns VNode. Function can be used for performance improvement and additional renders.
         */
        "registerVNode"?: (
    | VNode
    | ((c: ExtraNodeFuncConfig) => VNode)
  )[];
        /**
          * When true, columns are resizable.
         */
        "resize"?: boolean;
        /**
          * Row class property mapping. Map custom classes to rows from row object data. Define this property in rgRow object and this will be mapped as rgRow class.
         */
        "rowClass"?: string;
        /**
          * Custom row properies to be applied. See `RowDefinition` for more info.
         */
        "rowDefinitions"?: RowDefinition[];
        /**
          * Excel like functionality. Show row numbers. Also can be used for custom row header render if object provided.
         */
        "rowHeaders"?: RowHeaders | boolean;
        /**
          * Indicates default rgRow size. By default 0, means theme package size will be applied  Alternatively you can use `rowSize` to reset viewport
         */
        "rowSize"?: number;
        /**
          * Alternative way to set sorting. `{columns: [{prop: 'name', order: 'asc'}]}` Use SortingPlugin to get current sorting state
         */
        "sorting"?: SortingConfig;
        /**
          * Source - defines main data source. Can be an Object or 2 dimensional array([][]); Keys/indexes referenced from columns Prop.
         */
        "source"?: DataType[];
        /**
          * Stretch strategy for columns by `StretchColumn` plugin. For example if there are more space on the right last column size would be increased.
         */
        "stretch"?: boolean | string;
        /**
          * Theme name.
         */
        "theme"?: Theme;
        /**
          * Trimmed rows. Functionality which allows to hide rows from main data set. `trimmedRows` are physical `rgRow` indexes to hide.
         */
        "trimmedRows"?: Record<number, boolean>;
        /**
          * When true enable clipboard.
         */
        "useClipboard"?: boolean;
    }
    interface RevogrAttribution {
    }
    /**
     * This Clipboard provides functionality for handling clipboard events in a web application.
     */
    interface RevogrClipboard {
        /**
          * Paste 4. Fired after paste applied to the grid defaultPrevented - if true, paste will be canceled
         */
        "onAfterpasteapply"?: (event: RevogrClipboardCustomEvent<{
    raw: string;
    parsed: string[][];
    event: ClipboardEvent;
  }>) => void;
        /**
          * Copy 1. Fired before copy triggered defaultPrevented - if true, copy will be canceled
         */
        "onBeforecopy"?: (event: RevogrClipboardCustomEvent<{
    event: ClipboardEvent;
  }>) => void;
        /**
          * Copy Method 1. Fired before copy applied to the clipboard from outside. defaultPrevented - if true, copy will be canceled
         */
        "onBeforecopyapply"?: (event: RevogrClipboardCustomEvent<{
    event: DataTransfer;
    data?: string[][];
  }>) => void;
        /**
          * Cut 1. Fired before cut triggered defaultPrevented - if true, cut will be canceled
         */
        "onBeforecut"?: (event: RevogrClipboardCustomEvent<{
    event: ClipboardEvent;
  }>) => void;
        /**
          * Paste 1. Fired before paste applied to the grid defaultPrevented - if true, paste will be canceled
         */
        "onBeforepaste"?: (event: RevogrClipboardCustomEvent<{
    raw: string;
    isHTML: boolean;
    event: ClipboardEvent;
    dataText: string;
  }>) => void;
        /**
          * Paste 2. Fired before paste applied to the grid and after data parsed
         */
        "onBeforepasteapply"?: (event: RevogrClipboardCustomEvent<{
    raw: string;
    parsed: string[][];
    event: ClipboardEvent;
  }>) => void;
        /**
          * Cut 2. Clears region when cut is done
         */
        "onClearregion"?: (event: RevogrClipboardCustomEvent<DataTransfer>) => void;
        /**
          * Copy 2. Fired when region copied defaultPrevented - if true, copy will be canceled
         */
        "onCopyregion"?: (event: RevogrClipboardCustomEvent<DataTransfer>) => void;
        /**
          * Paste 3. Internal method. When data region is ready pass it to the top.
          * @property {string[][]} data - data to paste
          * @property {boolean} defaultPrevented - if true, paste will be canceled
         */
        "onPasteregion"?: (event: RevogrClipboardCustomEvent<string[][]>) => void;
        /**
          * If readonly mode - disabled Paste event
         */
        "readonly"?: boolean;
    }
    /**
     * This component is responsible for rendering data
     * Rows, columns, groups and cells
     */
    interface RevogrData {
        /**
          * Additional data to pass to renderer Used in plugins such as vue or react to pass root app entity to cells
         */
        "additionalData"?: any;
        /**
          * Column source
         */
        "colData": Observable<DSourceState<ColumnRegular, DimensionCols>>;
        /**
          * Column data type
         */
        "colType": DimensionCols | 'rowHeaders';
        /**
          * Data rows source
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings Y
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Prevent rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender"?: (Promise<any> | (() => Promise<any>))[];
        /**
          * When data render finished for the designated type
         */
        "onAfterrender"?: (event: RevogrDataCustomEvent<{ type: DimensionRows }>) => void;
        /**
          * Before each cell render function. Allows to override cell properties
         */
        "onBeforecellrender"?: (event: RevogrDataCustomEvent<BeforeCellRenderEvent<CellTemplateProp>>) => void;
        /**
          * Before data render
         */
        "onBeforedatarender"?: (event: RevogrDataCustomEvent<AllDimensionType>) => void;
        /**
          * Before each row render
         */
        "onBeforerowrender"?: (event: RevogrDataCustomEvent<BeforeRowRenderEvent>) => void;
        /**
          * Event emitted on cell drag start
         */
        "onDragstartcell"?: (event: RevogrDataCustomEvent<DragStartEvent>) => void;
        /**
          * Range allowed
         */
        "range"?: boolean;
        /**
          * Readonly mode
         */
        "readonly"?: boolean;
        /**
          * Defines property from which to read row class
         */
        "rowClass"?: string;
        /**
          * Selection, range, focus for row selection
         */
        "rowSelectionStore": Observable<SelectionStoreState>;
        /**
          * Row data type
         */
        "type": DimensionRows;
        /**
          * Viewport X
         */
        "viewportCol": Observable<ViewportState>;
        /**
          * Viewport Y
         */
        "viewportRow": Observable<ViewportState>;
    }
    /**
     * Represents a cell editor in a grid.
     * It manages the editing of cells by handling events, saving data, rendering the editor UI,
     * and managing the lifecycle of the editor instance.
     */
    interface RevogrEdit {
        /**
          * Additional data to pass to renderer
         */
        "additionalData"?: any;
        /**
          * Column data for editor.
         */
        "column"?: ColumnDataSchemaModel | null;
        /**
          * Cell to edit data.
         */
        "editCell"?: EditCell;
        /**
          * Custom editors register
         */
        "editor"?: EditorCtr | null;
        /**
          * Cell edit event initiator, first in the cellEdit event chain
         */
        "onCelleditinit"?: (event: RevogrEditCustomEvent<SaveDataDetails>) => void;
        /**
          * Close editor event pass true if requires focus next
         */
        "onCloseedit"?: (event: RevogrEditCustomEvent<boolean | undefined>) => void;
        /**
          * Save on editor close. Defines if data should be saved on editor close.
         */
        "saveOnClose"?: boolean;
    }
    /**
     * Contains extra elements for stencil components.
     * Performs rendering and updates for external components.
     * @example In Plugins if you want to add extra elements to grid and use stenciljs vnodes reactivity:
     * function paginationPanel(this: PaginationPlugin, config: { refresh: () => void }) {
     *    // use `config.refresh()` for component to re-render
     *    return h('div')
     * }
     * revogrid.registerVNode = [
     *    ...existingNodes,
     *     paginationPanel.bind(this)
     * ];
     * /**
     */
    interface RevogrExtra {
        /**
          * Nodes to render
         */
        "nodes"?: (
    | VNode
    | ((c: ExtraNodeFuncConfig) => VNode)
  )[];
    }
    interface RevogrFilterPanel {
        /**
          * If true, closes the filter panel when clicking outside
         */
        "closeOnOutsideClick"?: boolean;
        /**
          * Disables dynamic filtering. A way to apply filters on Save only
         */
        "disableDynamicFiltering"?: boolean;
        "filterCaptions"?: Partial<FilterCaptions> | undefined;
        "filterEntities"?: Record<string, LogicFunction>;
        "filterNames"?: Record<string, string>;
        "onFilterChange"?: (event: RevogrFilterPanelCustomEvent<MultiFilterItem>) => void;
        "onResetChange"?: (event: RevogrFilterPanelCustomEvent<ColumnProp>) => void;
    }
    /**
     * Focus component. Shows focus layer around the cell that is currently in focus.
     * @example focus-rgCol-rgRow
     */
    interface RevogrFocus {
        /**
          * Column source
         */
        "colData": Observable<DSourceState<ColumnRegular, DimensionCols>>;
        /**
          * Column type
         */
        "colType": DimensionCols;
        /**
          * Data rows source
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings X
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Dimension settings Y
         */
        "dimensionRow": Observable<DimensionSettingsState>;
        /**
          * Focus template custom function. Can be used to render custom focus layer.
         */
        "focusTemplate"?: FocusTemplateFunc | null;
        /**
          * Used to setup properties after focus was rendered
         */
        "onAfterfocus"?: (event: RevogrFocusCustomEvent<FocusAfterRenderEvent>) => void;
        /**
          * Before focus render event. Can be prevented by event.preventDefault(). If preventDefault used slot will be rendered.
         */
        "onBeforefocusrender"?: (event: RevogrFocusCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before focus changed verify if it's in view and scroll viewport into this view Can be prevented by event.preventDefault()
         */
        "onBeforescrollintoview"?: (event: RevogrFocusCustomEvent<{ el: HTMLElement }>) => void;
        /**
          * Row type
         */
        "rowType": DimensionRows;
        /**
          * Selection, range, focus for selection
         */
        "selectionStore": Observable<SelectionStoreState>;
    }
    interface RevogrHeader {
        /**
          * Extra properties to pass into header renderer, such as vue or react components to handle parent
         */
        "additionalData"?: any;
        /**
          * If columns can be resized
         */
        "canResize"?: boolean;
        /**
          * Columns - defines an array of grid columns.
         */
        "colData"?: ColumnRegular[];
        /**
          * Column filter
         */
        "columnFilter"?: boolean;
        /**
          * Dimension settings X
         */
        "dimensionCol"?: Observable<DimensionSettingsState>;
        /**
          * Grouping depth, how many levels of grouping
         */
        "groupingDepth"?: number;
        /**
          * Column groups
         */
        "groups"?: Groups;
        /**
          * After all header cells rendered. Finalizes cell rendering.
         */
        "onAfterheaderrender"?: (event: RevogrHeaderCustomEvent<ProvidersColumns>) => void;
        /**
          * Before each group header cell render function. Allows to override group header cell properties
         */
        "onBeforegroupheaderrender"?: (event: RevogrHeaderCustomEvent<HeaderGroupRendererProps>) => void;
        /**
          * On initial header click
         */
        "onBeforeheaderclick"?: (event: RevogrHeaderCustomEvent<InitialHeaderClick>) => void;
        /**
          * Before each header cell render function. Allows to override cell properties
         */
        "onBeforeheaderrender"?: (event: RevogrHeaderCustomEvent<HeaderRenderProps>) => void;
        /**
          * On before header resize
         */
        "onBeforeheaderresize"?: (event: RevogrHeaderCustomEvent<ColumnRegular[]>) => void;
        /**
          * On header double click
         */
        "onHeaderdblclick"?: (event: RevogrHeaderCustomEvent<InitialHeaderClick>) => void;
        /**
          * On header resize
         */
        "onHeaderresize"?: (event: RevogrHeaderCustomEvent<ViewSettingSizeProp>) => void;
        /**
          * Readonly mode
         */
        "readonly"?: boolean;
        /**
          * Defines resize position
         */
        "resizeHandler"?: ResizeProps['active'];
        /**
          * Selection, range, focus
         */
        "selectionStore"?: Observable<SelectionStoreState>;
        /**
          * Column type
         */
        "type": DimensionCols | 'rowHeaders';
        /**
          * Viewport X
         */
        "viewportCol"?: Observable<ViewportState>;
    }
    /**
     * Component for handling row order editor.
     */
    interface RevogrOrderEditor {
        /**
          * Static stores, not expected to change during component lifetime
         */
        "dataStore"?: Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings X
         */
        "dimensionCol"?: Observable<DimensionSettingsState>;
        /**
          * Dimension settings Y
         */
        "dimensionRow"?: Observable<DimensionSettingsState>;
        /**
          * Row drag ended started
         */
        "onRowdragendinit"?: (event: RevogrOrderEditorCustomEvent<{ rowType: DimensionRows }>) => void;
        /**
          * Row mouse move started
         */
        "onRowdragmousemove"?: (event: RevogrOrderEditorCustomEvent<Cell & { rowType: DimensionRows }>) => void;
        /**
          * Row move started
         */
        "onRowdragmoveinit"?: (event: RevogrOrderEditorCustomEvent<PositionItem & { rowType: DimensionRows }>) => void;
        /**
          * Row drag started
         */
        "onRowdragstartinit"?: (event: RevogrOrderEditorCustomEvent<RowDragStartDetails>) => void;
        /**
          * Row dragged, new range ready to be applied
         */
        "onRowdropinit"?: (event: RevogrOrderEditorCustomEvent<{
    from: number;
    to: number;
    rowType: DimensionRows;
  }>) => void;
        /**
          * Row drag ended finished. Time to apply data
         */
        "onRoworderchange"?: (event: RevogrOrderEditorCustomEvent<{
    from: number;
    to: number;
    rowType: DimensionRows;
  }>) => void;
        /**
          * Parent element
         */
        "parent"?: HTMLElement;
        "rowType"?: DimensionRows;
    }
    /**
     * Component for overlaying the grid with the selection.
     */
    interface RevogrOverlaySelection {
        /**
          * Additional data to pass to renderer.
         */
        "additionalData"?: any;
        /**
          * If true applys changes when cell closes if not Escape.
         */
        "applyChangesOnClose"?: boolean;
        /**
          * Enable revogr-order-editor component (read more in revogr-order-editor component). Allows D&D.
         */
        "canDrag"?: boolean;
        /**
          * Column data store.
         */
        "colData": Observable<DSourceState<ColumnRegular, DimensionCols>>;
        /**
          * Row data store.
         */
        "dataStore": Observable<DSourceState<DataType, DimensionRows>>;
        /**
          * Dimension settings X.
         */
        "dimensionCol": Observable<DimensionSettingsState>;
        /**
          * Dimension settings Y.
         */
        "dimensionRow"?: Observable<DimensionSettingsState>;
        /**
          * Custom editors register.
         */
        "editors"?: Editors;
        /**
          * Is mobile view mode.
         */
        "isMobileDevice"?: boolean;
        /**
          * Last real coordinates positions + 1.
         */
        "lastCell"?: Cell;
        /**
          * Before cell get focused. To prevent the default behavior of applying the edit data, you can call `e.preventDefault()`.
         */
        "onApplyfocus"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before range applied. First step in triggerRangeEvent.
         */
        "onBeforeapplyrange"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before cell focus.
         */
        "onBeforecellfocusinit"?: (event: RevogrOverlaySelectionCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Runs before cell save. Can be used to override or cancel original save.
         */
        "onBeforecellsave"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Before clipboard copy happened. Validate data before copy. To prevent the default behavior of editing data and use your own implementation, call `e.preventDefault()`.
         */
        "onBeforecopyregion"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Before editor render.
         */
        "onBeforeeditrender"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before key up event proxy, used to prevent key up trigger. If you have some custom behaviour event, use this event to check if it wasn't processed by internal logic. Call preventDefault().
         */
        "onBeforekeydown"?: (event: RevogrOverlaySelectionCustomEvent<{ original: KeyboardEvent } & EventData>) => void;
        /**
          * Before key down event proxy, used to prevent key down trigger. If you have some custom behaviour event, use this event to check if it wasn't processed by internal logic. Call preventDefault().
         */
        "onBeforekeyup"?: (event: RevogrOverlaySelectionCustomEvent<{ original: KeyboardEvent } & EventData>) => void;
        /**
          * Fired when change of viewport happens. Usually when we switch between pinned regions.
         */
        "onBeforenextvpfocus"?: (event: RevogrOverlaySelectionCustomEvent<Cell>) => void;
        /**
          * Before region paste happened.
         */
        "onBeforepasteregion"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Before range copy.
         */
        "onBeforerangecopyapply"?: (event: RevogrOverlaySelectionCustomEvent<ChangedRange>) => void;
        /**
          * Range data apply.
         */
        "onBeforerangedataapply"?: (event: RevogrOverlaySelectionCustomEvent<FocusRenderEvent>) => void;
        /**
          * Before range selection applied. Second step in triggerRangeEvent.
         */
        "onBeforesetrange"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Before set temp range area during autofill.
         */
        "onBeforesettemprange"?: (event: RevogrOverlaySelectionCustomEvent<{ tempRange: Nullable<TempRange> | null } & EventData & AllDimensionType>) => void;
        /**
          * Cancel edit. Used for editors support when editor close requested.
         */
        "onCanceledit"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Runs when edit finished save started, first in chain event
         */
        "onCelledit"?: (event: RevogrOverlaySelectionCustomEvent<SaveDataDetails>) => void;
        /**
          * Cell edit apply to the data source. Triggers datasource edit on the root level.
         */
        "onCelleditapply"?: (event: RevogrOverlaySelectionCustomEvent<BeforeSaveDataDetails>) => void;
        /**
          * Range copy.
         */
        "onClipboardrangecopy"?: (event: RevogrOverlaySelectionCustomEvent<RangeClipboardCopyEventProps>) => void;
        /**
          * Range paste event.
         */
        "onClipboardrangepaste"?: (event: RevogrOverlaySelectionCustomEvent<RangeClipboardPasteEvent>) => void;
        /**
          * Cell get focused. To prevent the default behavior of applying the edit data, you can call `e.preventDefault()`.
         */
        "onFocuscell"?: (event: RevogrOverlaySelectionCustomEvent<ApplyFocusEvent & FocusRenderEvent>) => void;
        /**
          * Range data apply. Triggers datasource edit on the root level.
         */
        "onRangeeditapply"?: (event: RevogrOverlaySelectionCustomEvent<BeforeRangeSaveDataDetails>) => void;
        /**
          * Select all cells from keyboard.
         */
        "onSelectall"?: (event: RevogrOverlaySelectionCustomEvent<any>) => void;
        /**
          * Autofill data in range. First step in applyRangeWithData
         */
        "onSelectionchangeinit"?: (event: RevogrOverlaySelectionCustomEvent<ChangedRange>) => void;
        /**
          * Set edit cell.
         */
        "onSetedit"?: (event: RevogrOverlaySelectionCustomEvent<BeforeEdit>) => void;
        /**
          * Set range. Third step in triggerRangeEvent.
         */
        "onSetrange"?: (event: RevogrOverlaySelectionCustomEvent<RangeArea & { type: MultiDimensionType }>) => void;
        /**
          * Set temp range area during autofill.
         */
        "onSettemprange"?: (event: RevogrOverlaySelectionCustomEvent<Nullable<TempRange> | null>) => void;
        /**
          * Range selection allowed.
         */
        "range"?: boolean;
        /**
          * Readonly mode.
         */
        "readonly"?: boolean;
        /**
          * Selection, range, focus.
         */
        "selectionStore": Observable<SelectionStoreState>;
        /**
          * Enable revogr-clipboard component (read more in revogr-clipboard component). Allows copy/paste.
         */
        "useClipboard"?: boolean;
    }
    /**
     * Row headers component
     * Visible on the left side of the table
     */
    interface RevogrRowHeaders {
        /**
          * Additional data to pass to renderer
         */
        "additionalData"?: any;
        /**
          * Viewport data
         */
        "dataPorts"?: ViewportData[];
        /**
          * Header props
         */
        "headerProp"?: Record<string, any>;
        /**
          * Header height to setup row headers
         */
        "height"?: number;
        /**
          * Prevent rendering until job is done. Can be used for initial rendering performance improvement. When several plugins require initial rendering this will prevent double initial rendering.
         */
        "jobsBeforeRender"?: Promise<any>[];
        /**
          * Register element to scroll
         */
        "onRef"?: (event: RevogrRowHeadersCustomEvent<ElementScroll>) => void;
        /**
          * Scroll viewport
         */
        "onScrollview"?: (event: RevogrRowHeadersCustomEvent<ViewPortScrollEvent>) => void;
        /**
          * Enable resize
         */
        "resize"?: boolean;
        /**
          * Row class
         */
        "rowClass"?: string;
        /**
          * Row header column
         */
        "rowHeaderColumn"?: RowHeaders;
    }
    /**
     * Virtual scroll component
     */
    interface RevogrScrollVirtual {
        /**
          * Client size
         */
        "clientSize": number;
        /**
          * Scroll dimension (`X` - `rgCol` or `Y` - `rgRow`)
         */
        "dimension"?: DimensionType;
        /**
          * Scroll event
         */
        "onScrollvirtual"?: (event: RevogrScrollVirtualCustomEvent<ViewPortScrollEvent>) => void;
        /**
          * Dimensions
         */
        "realSize": number;
        /**
          * Virtual size
         */
        "virtualSize": number;
    }
    /**
     * Temporary range selection component. Shows temporary range selection.
     */
    interface RevogrTempRange {
        /**
          * Dimension column store
         */
        "dimensionCol"?: Observable<DimensionSettingsState>;
        /**
          * Dimension row store
         */
        "dimensionRow"?: Observable<DimensionSettingsState>;
        /**
          * Selection store, shows current selection and focus
         */
        "selectionStore"?: Observable<SelectionStoreState>;
    }
    /**
     * Viewport scroll component for RevoGrid
     */
    interface RevogrViewportScroll {
        "colType": DimensionCols | 'rowHeaders';
        /**
          * Height of inner content
         */
        "contentHeight"?: number;
        /**
          * Width of inner content
         */
        "contentWidth"?: number;
        /**
          * Viewport resize
         */
        "onResizeviewport"?: (event: RevogrViewportScrollCustomEvent<ViewPortResizeEvent>) => void;
        /**
          * Triggered on scroll change, can be used to get information about scroll visibility
         */
        "onScrollchange"?: (event: RevogrViewportScrollCustomEvent<{
    type: DimensionType;
    hasScroll: boolean;
  }>) => void;
        /**
          * Before scroll event
         */
        "onScrollviewport"?: (event: RevogrViewportScrollCustomEvent<ViewPortScrollEvent>) => void;
        /**
          * Silently scroll to coordinate Made to align negative coordinates for mobile devices
         */
        "onScrollviewportsilent"?: (event: RevogrViewportScrollCustomEvent<ViewPortScrollEvent>) => void;
        /**
          * Enable row header
         */
        "rowHeader"?: boolean;
    }
    interface VnodeHtml {
        "onHtml"?: (event: VnodeHtmlCustomEvent<{ html: string; vnodes: (VNode[]) | null }>) => void;
        "redraw"?: (() => VNode[]) | null | undefined;
    }
    interface IntrinsicElements {
        "revo-grid": RevoGrid;
        "revogr-attribution": RevogrAttribution;
        "revogr-clipboard": RevogrClipboard;
        "revogr-data": RevogrData;
        "revogr-edit": RevogrEdit;
        "revogr-extra": RevogrExtra;
        "revogr-filter-panel": RevogrFilterPanel;
        "revogr-focus": RevogrFocus;
        "revogr-header": RevogrHeader;
        "revogr-order-editor": RevogrOrderEditor;
        "revogr-overlay-selection": RevogrOverlaySelection;
        "revogr-row-headers": RevogrRowHeaders;
        "revogr-scroll-virtual": RevogrScrollVirtual;
        "revogr-temp-range": RevogrTempRange;
        "revogr-viewport-scroll": RevogrViewportScroll;
        "vnode-html": VnodeHtml;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Revogrid - High-performance, customizable grid library for managing large datasets.
             * ### Events guide
             * For a comprehensive events guide, check the [Events API Page](/guide/api/events).
             * All events propagate to the root level of the grid. [Dependency tree](#Dependencies).
             * ### Type definitions
             * Read [type definition file](https://github.com/revolist/revogrid/blob/master/src/interfaces.d.ts) for the full interface information.
             * All complex property types such as `ColumnRegular`, `ColumnProp`, `ColumnDataSchemaModel` can be found there.
             * ### HTMLRevoGridElement
             * @example data-rgCol-rgRow - main data slot. Applies extra elements in <revogr-data />.
             * @example focus-rgCol-rgRow - focus layer for main data. Applies extra elements in <revogr-focus />.
             */
            "revo-grid": LocalJSX.RevoGrid & JSXBase.HTMLAttributes<HTMLRevoGridElement>;
            "revogr-attribution": LocalJSX.RevogrAttribution & JSXBase.HTMLAttributes<HTMLRevogrAttributionElement>;
            /**
             * This Clipboard provides functionality for handling clipboard events in a web application.
             */
            "revogr-clipboard": LocalJSX.RevogrClipboard & JSXBase.HTMLAttributes<HTMLRevogrClipboardElement>;
            /**
             * This component is responsible for rendering data
             * Rows, columns, groups and cells
             */
            "revogr-data": LocalJSX.RevogrData & JSXBase.HTMLAttributes<HTMLRevogrDataElement>;
            /**
             * Represents a cell editor in a grid.
             * It manages the editing of cells by handling events, saving data, rendering the editor UI,
             * and managing the lifecycle of the editor instance.
             */
            "revogr-edit": LocalJSX.RevogrEdit & JSXBase.HTMLAttributes<HTMLRevogrEditElement>;
            /**
             * Contains extra elements for stencil components.
             * Performs rendering and updates for external components.
             * @example In Plugins if you want to add extra elements to grid and use stenciljs vnodes reactivity:
             * function paginationPanel(this: PaginationPlugin, config: { refresh: () => void }) {
             *    // use `config.refresh()` for component to re-render
             *    return h('div')
             * }
             * revogrid.registerVNode = [
             *    ...existingNodes,
             *     paginationPanel.bind(this)
             * ];
             * /**
             */
            "revogr-extra": LocalJSX.RevogrExtra & JSXBase.HTMLAttributes<HTMLRevogrExtraElement>;
            "revogr-filter-panel": LocalJSX.RevogrFilterPanel & JSXBase.HTMLAttributes<HTMLRevogrFilterPanelElement>;
            /**
             * Focus component. Shows focus layer around the cell that is currently in focus.
             * @example focus-rgCol-rgRow
             */
            "revogr-focus": LocalJSX.RevogrFocus & JSXBase.HTMLAttributes<HTMLRevogrFocusElement>;
            "revogr-header": LocalJSX.RevogrHeader & JSXBase.HTMLAttributes<HTMLRevogrHeaderElement>;
            /**
             * Component for handling row order editor.
             */
            "revogr-order-editor": LocalJSX.RevogrOrderEditor & JSXBase.HTMLAttributes<HTMLRevogrOrderEditorElement>;
            /**
             * Component for overlaying the grid with the selection.
             */
            "revogr-overlay-selection": LocalJSX.RevogrOverlaySelection & JSXBase.HTMLAttributes<HTMLRevogrOverlaySelectionElement>;
            /**
             * Row headers component
             * Visible on the left side of the table
             */
            "revogr-row-headers": LocalJSX.RevogrRowHeaders & JSXBase.HTMLAttributes<HTMLRevogrRowHeadersElement>;
            /**
             * Virtual scroll component
             */
            "revogr-scroll-virtual": LocalJSX.RevogrScrollVirtual & JSXBase.HTMLAttributes<HTMLRevogrScrollVirtualElement>;
            /**
             * Temporary range selection component. Shows temporary range selection.
             */
            "revogr-temp-range": LocalJSX.RevogrTempRange & JSXBase.HTMLAttributes<HTMLRevogrTempRangeElement>;
            /**
             * Viewport scroll component for RevoGrid
             */
            "revogr-viewport-scroll": LocalJSX.RevogrViewportScroll & JSXBase.HTMLAttributes<HTMLRevogrViewportScrollElement>;
            "vnode-html": LocalJSX.VnodeHtml & JSXBase.HTMLAttributes<HTMLVnodeHtmlElement>;
        }
    }
}
